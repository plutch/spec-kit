# Spec-Kit v2.3.0 Migration Guide

**Upgrading from v2.1 or v2.2 to v2.3.0**

This guide helps you migrate existing projects to Spec-Kit v2.3.0, which introduces unified state management, EARS requirements format, and phase tracking.

---

## What's New in v2.3.0?

### Major Changes
1. **Unified State Management**: spec-metadata.json replaces state.json as primary state file
2. **EARS Requirements Format**: Structured requirements (WHEN/IF/WHILE/WHERE patterns)
3. **Phase Tracking & Approval Gates**: Six-phase workflow with approval gates
4. **Memory System**: Persistent AI context across sessions
5. **Live Context Gathering**: Git diff integration for reconciliation

### Breaking Changes
- ‚ö†Ô∏è **State file location changed**: `specs/{FEATURE}/spec-metadata.json` (was `.specify/memory/features/{FEATURE}/state.json`)
- ‚ö†Ô∏è **Phase names changed**: Lowercase format (was UPPERCASE)
- ‚ö†Ô∏è **New commands added**: `/speckit.memory`, `/speckit.status`, `/speckit.validate-gap`

### Backward Compatibility
‚úÖ **v2.3.0 maintains backward compatibility** with v2.1/v2.2:
- Commands read state.json as fallback if spec-metadata.json missing
- Automatic phase mapping between formats
- Dual state tracking during migration period

---

## Migration Path

### Option 1: Fresh Start (Recommended for New Features)

**Best for**: Starting new features after upgrade

1. Copy new v2.3.0 files to your project:
   ```bash
   # Backup existing files
   cp -r .claude .claude.backup
   cp -r .specify .specify.backup

   # Copy v2.3.0 files
   cp -r /path/to/spec-kit/src/.claude .
   cp -r /path/to/spec-kit/src/.specify .
   ```

2. Initialize memory system:
   ```bash
   /speckit.memory
   # Creates constitution.md, api-standards.md, testing-approach.md
   ```

3. Start new feature with v2.3.0 workflow:
   ```bash
   /speckit.specify "New feature description"
   # Automatically creates spec-metadata.json with v2.3.0 format
   ```

**Benefit**: Full v2.3.0 features immediately, clean state management.

---

### Option 2: Gradual Migration (For Existing Features)

**Best for**: Continuing work on features started in v2.1/v2.2

#### Step 1: Upgrade Framework Files
```bash
# Backup
cp -r .claude .claude.backup
cp -r .specify .specify.backup

# Update commands only (preserve your existing specs and state)
cp -r /path/to/spec-kit/src/.claude .

# Add new templates
cp -r /path/to/spec-kit/src/.specify/templates .specify/
cp -r /path/to/spec-kit/src/.specify/memory .specify/
```

#### Step 2: Continue Using state.json (Automatic)
- **No action needed** - v2.3.0 commands automatically read state.json as fallback
- Your existing features work without modification
- Workflow continues with state.json

#### Step 3: Migrate to spec-metadata.json (Optional, Per Feature)

**Migrate one feature at a time**:

1. **Create spec-metadata.json from existing state.json**:
   ```bash
   # For feature 000003-billing-console
   cd specs/000003-billing-console/

   # Read existing state.json
   cat ../../.specify/memory/features/000003-billing-console/state.json

   # Create spec-metadata.json
   # Convert phase: PLANNING ‚Üí planning, IMPLEMENTING ‚Üí implementation
   ```

   **Example conversion**:
   ```json
   # OLD: state.json (v2.1/v2.2)
   {
     "phase": "PLANNING",
     "progress": 45,
     "feature_num": "000003"
   }

   # NEW: spec-metadata.json (v2.3.0)
   {
     "version": "2.3.0",
     "feature_name": "billing-console",
     "phase": "planning",
     "approvals": {
       "specification": { "generated": true, "approved": true, "timestamp": "2025-10-15T10:00:00Z" },
       "planning": { "generated": true, "approved": false, "timestamp": "2025-10-20T14:00:00Z" }
     },
     "metadata": {
       "created_at": "2025-10-15T10:00:00Z",
       "risk_level": "MEDIUM",
       "overall_quality": 7.5
     }
   }
   ```

2. **Phase Mapping Reference**:
   ```yaml
   OLD (state.json)    ‚Üí   NEW (spec-metadata.json)
   SPECIFYING          ‚Üí   specification
   CLARIFYING          ‚Üí   clarifying
   PLANNING            ‚Üí   planning
   TASKING             ‚Üí   tasks
   IMPLEMENTING        ‚Üí   implementation
   RECONCILING         ‚Üí   reconciliation
   VALIDATING          ‚Üí   validating
   COMPLETED           ‚Üí   complete
   ```

3. **Run /speckit.status to verify**:
   ```bash
   /speckit.status

   # Should show:
   # ‚úÖ spec-metadata.json loaded
   # Phase: planning (converted from state.json)
   ```

**Benefit**: Smooth transition per feature, no rush to migrate everything.

---

## Feature-by-Feature Upgrade

### Existing Feature in PLANNING Phase (v2.1/v2.2)

**Before (v2.1/v2.2)**:
```
specs/000001-auth/
  ‚îú‚îÄ‚îÄ spec.md
  ‚îú‚îÄ‚îÄ plan.md
  ‚îî‚îÄ‚îÄ (no metadata)

.specify/memory/features/000001-auth/
  ‚îî‚îÄ‚îÄ state.json   # Contains: phase: "PLANNING"
```

**After Migration (v2.3.0)**:
```
specs/000001-auth/
  ‚îú‚îÄ‚îÄ spec.md
  ‚îú‚îÄ‚îÄ plan.md
  ‚îî‚îÄ‚îÄ spec-metadata.json   # NEW: Primary state file

.specify/memory/features/000001-auth/
  ‚îî‚îÄ‚îÄ state.json   # Kept for backward compatibility (optional)
```

**Migration Steps**:
1. Run `/speckit.status` - reads state.json automatically
2. Continue with `/speckit.tasks` - works with state.json
3. (Optional) Create spec-metadata.json manually for full v2.3.0 features
4. Future commands update both files during transition

---

### Starting Fresh Feature (v2.3.0)

**Command**:
```bash
/speckit.specify "User profile management with avatar upload"
```

**Output**:
```
specs/000004-user-profile/
  ‚îú‚îÄ‚îÄ spec.md                  # With EARS requirements
  ‚îî‚îÄ‚îÄ spec-metadata.json       # Auto-created with v2.3.0 format

# No state.json created (v2.3.0 standard)
```

**Next Steps**:
```bash
/speckit.status                # Shows phase: specification
/speckit.clarify               # Updates spec-metadata.json
/speckit.analyze               # Adds quality scores to metadata
/speckit.plan                  # Creates plan.md, updates metadata
```

---

## EARS Requirements Migration

### Option 1: Add EARS to Existing Specs (Manual)

Update your existing spec.md requirements section:

**Before (v2.1/v2.2)**:
```markdown
## Functional Requirements

- Users can log in with email and password
- Session should expire after inactivity
- Failed login attempts should be limited
```

**After (v2.3.0 EARS format)**:
```markdown
## Functional Requirements

**REQ-AUTH-1.1**: WHEN user submits valid credentials THEN the Authentication Service SHALL grant access within 2 seconds

**REQ-AUTH-1.2**: IF user is inactive for 15 minutes THEN the Session Manager SHALL terminate the session

**REQ-AUTH-1.3**: WHEN user enters invalid password 3 times THEN the system SHALL lock the account for 15 minutes
```

### Option 2: Regenerate Spec with EARS (Risky)

‚ö†Ô∏è **Warning**: This replaces your existing spec. Only do if spec is incomplete or early stage.

```bash
# Backup first!
cp specs/000001-auth/spec.md specs/000001-auth/spec.md.backup

# Regenerate
/speckit.specify "User authentication with session management"

# Review changes
diff specs/000001-auth/spec.md.backup specs/000001-auth/spec.md
```

### Option 3: Hybrid Approach (Safe)

Keep existing requirements, add EARS for new features only:

```markdown
## Functional Requirements

### Existing Requirements (v2.1 format)
- Users can log in with email and password
- Session expires after 15 minutes of inactivity

### New Requirements (v2.3 EARS format)
**REQ-AUTH-2.1**: WHEN user enables 2FA THEN the system SHALL require TOTP code on next login

**REQ-AUTH-2.2**: IF TOTP code is invalid THEN the system SHALL reject login with error message
```

---

## Memory System Setup

### Initialize Memory Files

**First Time Setup**:
```bash
/speckit.memory

# Creates:
# .specify/memory/constitution.md          (Always loaded)
# .specify/memory/api-standards.md         (Auto-loaded for API work)
# .specify/memory/testing-approach.md      (Auto-loaded for test work)
# .specify/memory/deployment-runbook.md    (Manual load)
```

**What Gets Extracted**:
- Tech stack from package.json
- Existing coding standards from README/docs
- Project structure patterns
- Testing frameworks detected

**Manual Review Required**:
Edit generated memory files to add:
- Your specific architecture decisions
- Team conventions not auto-detected
- Domain-specific patterns

---

## Command Changes Summary

### New Commands (v2.3.0)
| Command | Purpose | Priority |
|---------|---------|----------|
| `/speckit.memory` | Initialize memory system | **High** - Run once per project |
| `/speckit.status` | View workflow state | Medium - Use as needed |
| `/speckit.validate-gap` | Feasibility analysis | Medium - Auto-triggered for high-risk |

### Enhanced Commands (Backward Compatible)
| Command | v2.3.0 Enhancement | Action Required |
|---------|-------------------|------------------|
| `/speckit.specify` | EARS requirements, spec-metadata.json creation | None - works with old format |
| `/speckit.plan` | Requirements traceability | None - backward compatible |
| `/speckit.tasks` | EARS requirement tagging | None - optional feature |
| `/speckit.implement` | Approval gate checks | None - gracefully degrades |
| `/speckit.reconcile` | Git diff live context | None - adds new capability |
| `/speckit.analyze` | Metadata integration | None - backward compatible |
| `/speckit.analyze-ux` | Metadata integration | None - backward compatible |
| `/speckit.clarify` | Metadata tracking | None - backward compatible |
| `/speckit.pm` | Unified state management | None - reads state.json fallback |
| `/speckit.next` | Phase mapping support | None - works with both formats |

### Unchanged Commands
- `/speckit.constitution` - No changes
- `/speckit.supplement` - No changes
- `/speckit.amend-technical` - No changes
- `/speckit.validate-hierarchy` - Minor enhancement (auto-detection)

---

## Troubleshooting

### Issue 1: "State file not found" Error

**Symptom**: Commands report missing state files

**Cause**: Neither spec-metadata.json nor state.json exists

**Fix**:
```bash
# Option A: Run /speckit.pm to initialize
/speckit.pm

# Option B: Create spec-metadata.json manually
cd specs/YOUR-FEATURE/
# Create spec-metadata.json with current phase
```

---

### Issue 2: Phase Shows Wrong Value

**Symptom**: `/speckit.status` shows incorrect phase

**Cause**: Mismatch between spec-metadata.json and actual files

**Fix**:
```bash
# Check what files exist
ls specs/YOUR-FEATURE/

# If spec.md and plan.md exist but phase is "specification":
# Manually update spec-metadata.json:
{
  "phase": "planning",  // Match actual progress
  "approvals": {
    "specification": { "generated": true, "approved": true },
    "planning": { "generated": true, "approved": false }
  }
}
```

---

### Issue 3: Commands Still Using state.json

**Symptom**: Commands read state.json instead of spec-metadata.json

**Cause**: spec-metadata.json doesn't exist, fallback to state.json (expected behavior)

**Fix** (if you want to migrate):
```bash
# Create spec-metadata.json in spec directory
cd specs/YOUR-FEATURE/
# Convert state.json to spec-metadata.json format (see conversion example above)
```

**Or**: Do nothing - v2.3.0 works fine with state.json

---

### Issue 4: EARS Requirements Not Generated

**Symptom**: `/speckit.specify` doesn't create EARS format

**Cause**: Using old command file, or feature created before EARS integration

**Fix**:
```bash
# Verify command version
grep "Command Version" .claude/commands/speckit.specify.md
# Should show: 2.3.0

# If not 2.3.0, update commands:
cp /path/to/spec-kit/src/.claude/commands/speckit.specify.md .claude/commands/
```

---

## Rollback Plan

If you need to revert to v2.1/v2.2:

```bash
# Restore backup
rm -rf .claude
rm -rf .specify
cp -r .claude.backup .claude
cp -r .specify.backup .specify

# Your specs and code are unchanged
# Only framework files are restored

# If you created spec-metadata.json files:
find specs/ -name "spec-metadata.json" -delete
# state.json files remain intact
```

---

## Testing Your Migration

### Checklist

- [ ] Backup completed (`.claude.backup`, `.specify.backup`)
- [ ] New commands copied to `.claude/commands/`
- [ ] Memory files initialized (`/speckit.memory`)
- [ ] Existing features still accessible via `/speckit.pm`
- [ ] New features use EARS format (`/speckit.specify`)
- [ ] State tracking works (`/speckit.status`)

### Test Workflow (Existing Feature)

```bash
# 1. Check status
/speckit.status
# Should show current feature and phase

# 2. Continue workflow
/speckit.next
# Should recommend appropriate next command

# 3. Verify state updates
/speckit.clarify
/speckit.status
# Should show updated phase
```

### Test Workflow (New Feature)

```bash
# 1. Create new feature
/speckit.specify "Test feature with EARS"
# Check spec.md has EARS requirements

# 2. Verify metadata
cat specs/FEATURE/spec-metadata.json
# Should exist with v2.3.0 format

# 3. Full workflow
/speckit.clarify
/speckit.analyze
/speckit.plan
/speckit.tasks
# All should update spec-metadata.json
```

---

## Getting Help

### Resources

- **EARS Quick Reference**: [docs/EARS-QUICK-REFERENCE.md](EARS-QUICK-REFERENCE.md)
- **README**: [README.md](../README.md) - Full v2.3.0 feature list
- **GitHub Issues**: [github.com/anthropics/claude-code/issues](https://github.com/anthropics/claude-code/issues)

### Common Questions

**Q: Do I have to migrate all features at once?**
A: No. Migrate per feature as you work on them. v2.3.0 supports both formats.

**Q: Can I mix state.json and spec-metadata.json?**
A: Yes. Different features can use different formats. Commands detect automatically.

**Q: What if I don't want EARS format?**
A: You can continue with free-form requirements. EARS is optional but recommended.

**Q: Is there a performance impact?**
A: Minimal. Commands check spec-metadata.json first, then fallback to state.json. Adds ~10-50ms.

**Q: When should I delete state.json?**
A: After verifying spec-metadata.json works for your feature. Keep as backup during transition.

---

## Summary

**Recommended Migration Strategy**:

1. ‚úÖ **Backup everything** (commands, templates, specs)
2. ‚úÖ **Update framework files** (commands, templates)
3. ‚úÖ **Initialize memory system** (`/speckit.memory`)
4. ‚úÖ **Continue existing features** (automatic state.json fallback)
5. ‚úÖ **Start new features with v2.3.0** (EARS + spec-metadata.json)
6. ‚úÖ **Migrate existing features gradually** (one at a time, optional)

**Timeline**: 30-60 minutes for framework update, per-feature migration as needed

**Risk Level**: üü¢ LOW - Full backward compatibility, rollback available

---

**Last Updated**: 2025-11-05
**Spec-Kit Version**: 2.3.0
